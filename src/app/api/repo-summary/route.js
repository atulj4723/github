import dbConnect from "@/lib/dbConnet";
import { ai } from "@/lib/geminiConfig";
import { RepoModel } from "@/models/Repo";
import { Type } from "@google/genai";
import axios from "axios";

export async function POST(request) {
    try {
        await dbConnect();
        const { owner, repo } = await request.json();

        const repository = await RepoModel.findOne({ owner, repo });
        if (repository?.systemPrompt) {
            return Response.json(
                {
                    success: true,
                    message: "System Prompt generated successfully.",
                    data: repository.systemPrompt,
                },
                { status: 200 }
            );
        }
        const repoStructure = await axios.post(
            `${process.env.BASE_URL}/api/generate-repo-structure`,
            { owner, repo }
        );

        const array = await ai.models.generateContent({
            model: "gemini-2.0-flash",
            contents: [
                {
                    role: "user",
                    parts: [
                        {
                            text: `You are a repository analysis expert. 
I will provide you with the projects folder and file structure: 
${repoStructure.data.message} 
Your task is to analyze this structure and return a JSON array of folder and file names that are usually not useful for code summarization or documentation purposes. 
These may include build artifacts, dependencies, environment files,images,videos,audios test snapshots, or autogenerated files. 
Only include the names of the folders and files to skip. 
Do not include any explanation or extra text â€” just return a valid JSON array of strings.
`,
                        },
                    ],
                },
            ],
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.ARRAY,
                    items: {
                        type: Type.STRING,
                    },
                },
            },
        });
        const skippedList = JSON.parse(
            array?.candidates[0]?.content.parts[0].text
        );
        const { data } = await axios.post(
            `${process.env.BASE_URL}/api/get-repo-files`,
            {
                owner,
                repo,
            }
        );
        const summarizeFiles = (files, exclude) => {
            return files
                .map((file) => {
                    if (file.type === "dir") {
                        if (exclude.includes(file.name)) return null;

                        const filteredChildren = summarizeFiles(
                            file.files || [],
                            exclude
                        );

                        return { ...file, files: filteredChildren };
                    } else {
                        if (
                            exclude.includes(file.name) ||
                            exclude.some((ext) => file.name.endsWith(ext))
                        ) {
                            return null;
                        }
                        return file;
                    }
                })
                .filter(Boolean);
        };
        const finalData = summarizeFiles(data.data.files, skippedList);
        const final = async (finalData) => {
            return Promise.all(
                finalData.map(async (cur) => {
                    if (cur.type === "dir") {
                        const child = await final(cur.files);
                        return { ...cur, files: child };
                    } else {
                        const { data } = await axios.get(cur.download_url);
                        return { ...cur, content: data };
                    }
                })
            );
        };
        const content = await final(finalData);
        const res = await ai.models.generateContent({
            model: "gemini-2.0-flash",
            contents: [
                {
                    role: "user",
                    parts: [
                        {
                            text: `
Generate the summary of following repo:
Repo: ${repo}
Structure & Metadata:
${JSON.stringify(content, null, 2)}
Provide a clear overview of the repositorys purpose, functionality, and high-level description.
Summarize the technologies, frameworks, or languages used.
Explain the folder structure and what each key directory/file represents.
Describe the workflow or execution flow (how the project runs).
                            `,
                        },
                    ],
                },
            ],
        });
        const sys = res.candidates[0]?.content.parts[0].text;
        await RepoModel.findOneAndUpdate(
            { owner, repo },
            { $set: { systemPrompt: sys } }
        );
        return Response.json(
            {
                success: true,
                message: "System Prompt generated successfully.",
                data: sys,
            },
            { status: 200 }
        );
    } catch (e) {
        return Response.json(
            { success: false, error: e.message },
            { status: 500 }
        );
    }
}
